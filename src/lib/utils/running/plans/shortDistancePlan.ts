import { calculatePaceForVDOT } from "../jackDaniels";
import { WeekPlan, RunningPlanData, PlannedRun } from "@maratypes/runningPlan";

export const Units = ["miles", "kilometers"] as const;
export type Unit = (typeof Units)[number];

export enum TrainingLevel {
  Beginner = "beginner",
  Intermediate = "intermediate",
  Advanced = "advanced",
}

const MIN_WEEKS = 6;
const TAPER_WEEKS = 1;

const LONG_RUN_PCT = {
  beginner: { start: 1.0, peak: 1.3 },
  intermediate: { start: 1.2, peak: 1.5 },
  advanced: { start: 1.4, peak: 1.8 },
} as const;

const WEEKLY_MILEAGE_MULT = {
  beginner: { start: 2.0, peak: 3.0 },
  intermediate: { start: 2.5, peak: 4.0 },
  advanced: { start: 3.0, peak: 5.0 },
} as const;

const EASY_PCT = 0.5;
const INTERVAL_PCT = 0.2;
const TEMPO_PCT = 0.15;
const TAPER_ADJ = 0.7;

function chooseReps(totalMeters: number) {
  const options = [200, 400, 800, 1000];
  let rep = 400;
  for (const d of options) {
    const reps = Math.round(totalMeters / d);
    if (reps <= 10) {
      rep = d;
      break;
    }
  }
  const reps = Math.max(1, Math.round(totalMeters / rep));
  return { scheme: `${reps}×${rep}m`, totalMeters: reps * rep };
}

export function generateShortDistancePlan(
  weeks: number,
  raceDistance: number,
  distanceUnit: Unit,
  trainingLevel: TrainingLevel,
  vdot: number,
): RunningPlanData {
  if (weeks < MIN_WEEKS) throw new Error(`Plan must be ≥ ${MIN_WEEKS} weeks.`);
  if (raceDistance <= 0) throw new Error("Distance must be > 0");

  const kmPerMile = 1.60934;
  const toKm = (d: number) =>
    distanceUnit === "miles" ? d * kmPerMile : d;
  const fromKm = (d: number) =>
    distanceUnit === "miles" ? d / kmPerMile : d;
  const toMeters = distanceUnit === "miles" ? 1609.34 : 1000;

  const raceKm = toKm(raceDistance);
  const raceMeters = raceKm * 1000;

  const paceE = calculatePaceForVDOT(raceMeters, vdot, "E");
  const paceM = calculatePaceForVDOT(raceMeters, vdot, "M");
  const paceT = calculatePaceForVDOT(raceMeters, vdot, "T");
  const paceI = calculatePaceForVDOT(raceMeters, vdot, "I");

  const buildWeeks = weeks - TAPER_WEEKS;
  const phases = [
    ...Array(buildWeeks).fill("Build" as const),
    ...Array(TAPER_WEEKS).fill("Taper" as const),
  ];

  const schedule: WeekPlan[] = [];
  const { start: SM, peak: PM } = WEEKLY_MILEAGE_MULT[trainingLevel];
  const { start: LS, peak: LP } = LONG_RUN_PCT[trainingLevel];

  const round1 = (n: number) => Math.round(n * 10) / 10;

  for (let w = 1; w <= weeks; w++) {
    const phase = phases[w - 1];
    let weeklyMileageKm: number;
    if (phase === "Build") {
      const ratio = buildWeeks === 1 ? 1 : (w - 1) / (buildWeeks - 1);
      weeklyMileageKm = raceKm * (SM + (PM - SM) * ratio);
    } else {
      weeklyMileageKm = raceKm * PM;
    }
    weeklyMileageKm = round1(weeklyMileageKm);

    const easyKm = weeklyMileageKm * EASY_PCT;
    let intervalKm = weeklyMileageKm * INTERVAL_PCT;
    let tempoKm = weeklyMileageKm * TEMPO_PCT;

    const longPct =
      phase === "Build"
        ? LS + (LP - LS) * ((w - 1) / (buildWeeks - 1))
        : LP;
    let longKm = raceKm * longPct;

    if (phase === "Taper") {
      intervalKm *= TAPER_ADJ;
      tempoKm *= TAPER_ADJ;
      longKm *= TAPER_ADJ;
    }

    const intervalReps = chooseReps(intervalKm * 1000);
    const runs: PlannedRun[] = [
      {
        type: "easy",
        unit: distanceUnit,
        mileage: round1(fromKm(easyKm)),
        targetPace: { unit: distanceUnit, pace: paceE },
      },
      {
        type: "interval",
        unit: distanceUnit,
        mileage: round1(intervalReps.totalMeters / toMeters),
        targetPace: { unit: distanceUnit, pace: paceI },
        notes: `${intervalReps.scheme} @ I-pace`,
      },
      {
        type: "tempo",
        unit: distanceUnit,
        mileage: round1(fromKm(tempoKm)),
        targetPace: { unit: distanceUnit, pace: paceT },
        notes: `${tempoKm.toFixed(1)} km @ T-pace`,
      },
      {
        type: "long",
        unit: distanceUnit,
        mileage: round1(fromKm(longKm)),
        targetPace: { unit: distanceUnit, pace: paceE },
        notes: `${longKm.toFixed(1)} km @ E-pace`,
      },
    ];

    if (w === weeks) {
      runs[runs.length - 1] = {
        ...runs[runs.length - 1],
        type: "marathon",
        mileage: round1(fromKm(raceKm)),
        targetPace: { unit: distanceUnit, pace: paceM },
      };
    }

    const weeklyMileage = round1(runs.reduce((tot, r) => tot + r.mileage, 0));

    schedule.push({
      weekNumber: w,
      phase,
      unit: distanceUnit,
      weeklyMileage,
      runs,
      notes: phase === "Taper" ? "Taper week" : "Build week",
    });
  }

  return { weeks, schedule, notes: "Generated by Maratron" };
}
